# -*- coding: utf-8 -*-
"""HW_EKIMOV_BOT

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vYUQA8BEd4ogNE03aXyulj5fpfAfehVi
"""

!pip install pyTelegramBotAPI requests feedparser -q

import telebot
from telebot import types
import pandas as pd
import random
import requests
import re
import threading
import os

TOKEN = '8271222364:AAG_RYUZa-iEXt2u6AHLvCH2KQImcksgC-E'
bot = telebot.TeleBot(TOKEN)

TASKS_FILE = 'tasks.csv'
if not os.path.exists(TASKS_FILE):
    df = pd.DataFrame(columns=['user_id', 'task', 'done'])
    df.to_csv(TASKS_FILE, index=False)

def load_tasks():
    return pd.read_csv(TASKS_FILE)

def save_tasks(df):
    df.to_csv(TASKS_FILE, index=False)

@bot.message_handler(commands=['start'])
def start(m):
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, row_width=2)
    markup.add("Монетка", "Факт дня")
    markup.add("Переводчик", "Курс валют")
    markup.add("Калькулятор", "Напомни")
    markup.add("Добавить дело", "Мои дела")

    bot.send_message(m.chat.id,
        "Привет проверяющий!)\n\n"
        "7 функций:\n"
        "• Факт дня • Переводчик • Калькулятор\n"
        "• Курсы валют • Напоминания • Список дел\n"
        "• Монетка на удачу\n\n"
        "Данные хранятся в task.csv в коллабе\n"
        "Тема бота - личный помщник",
        reply_markup=markup, parse_mode='HTML')

@bot.message_handler(content_types=['text'])
def handle(m):
    t = m.text.lower()
    user_id = m.from_user.id

    if "монетк" in t:
        coin(m)
    elif "факт" in t:
        fact_of_day(m)
    elif "перевод" in t:
        msg = bot.send_message(m.chat.id, "Текст для перевода:");
        bot.register_next_step_handler(msg, translate)
    elif "курс" in t or "доллар" in t:
        currency(m)
    elif "кальк" in t or any(x in t for x in "+-*/()"):
        calculator(m)
    elif "напомни" in t:
        msg = bot.send_message(m.chat.id, "Через сколько минут?");
        bot.register_next_step_handler(msg, reminder_minutes)
    elif "добавить дело" in t:
        msg = bot.send_message(m.chat.id, "Что нужно сделать?");
        bot.register_next_step_handler(msg, lambda x: add_task(x, user_id))
    elif "мои дела" in t:
        show_tasks(m, user_id)
    else:
        bot.send_message(m.chat.id, "Нажми кнопку из меню")

# Монетка
def coin(m):
    kb = types.InlineKeyboardMarkup()
    kb.add(types.InlineKeyboardButton("Подбросить", callback_data="flip"))
    bot.send_message(m.chat.id, "Монетка на удачу", reply_markup=kb)

@bot.callback_query_handler(func=lambda c: c.data == "flip")
def flip(c):
    res = random.choice(["Орёл", "Решка"])
    bot.edit_message_text(f"Результат: <b>{res}</b>", c.message.chat.id, c.message.message_id, parse_mode='HTML')

# Факт
def fact_of_day(m):
    facts = [
        "Таганрог — родина А.П. Чехова",
        "В космосе нет звука",
        "Осьминоги имеют три сердца",
        "Бананы — это ягоды, а клубника — нет",
        "Пингвины дарят камешки своей паре",
        "Самый длинный брак длился 91 год",
        "Медузы старше динозавров на 400 млн лет"
    ]
    fact = random.choice(facts)
    bot.send_message(m.chat.id, f"Факт дня:\n\n{fact}")

# Переводчик
def translate(m):
    try:
        url = f"https://translate.google.com/m?sl=auto&tl={'en' if 'а'<=m.text[0].lower()<='я' else 'ru'}&q={requests.utils.quote(m.text)}"
        res = re.search(r'class="result-container">(.*?)</div>', requests.get(url, headers={'User-Agent': 'Mozilla/5.0'}).text)
        bot.send_message(m.chat.id, res.group(1) if res else "Не перевёл")
    except:
        bot.send_message(m.chat.id, "Ошибка перевода")

# Курс валют
def currency(m):
    try:
        r = requests.get("https://www.cbr.ru/scripts/XML_daily.asp")
        usd = re.search(r'USD.*?<Value>(.*?)</Value>', r.text).group(1)
        eur = re.search(r'EUR.*?<Value>(.*?)</Value>', r.text).group(1)
        bot.send_message(m.chat.id, f"Курсы ЦБ РФ:\nUSD = {usd} ₽\nEUR = {eur} ₽")
    except:
        bot.send_message(m.chat.id, "Не смог получить курсы")

# Калькулятор
def calculator(m):
    try:
        expr = re.sub(r'[^\d+\-*/(). ]', '', m.text)
        result = eval(expr)
        bot.send_message(m.chat.id, f"{expr} = <b>{result}</b>", parse_mode='HTML')
    except:
        bot.send_message(m.chat.id, "Ошибка")
# Работает так, пишешь в чат выражение, оно считает
# Напоминание
def reminder_minutes(m):
    try:
        mins = int(m.text)
        msg = bot.send_message(m.chat.id, "Что напомнить?")
        bot.register_next_step_handler(msg, lambda x: set_reminder(x, mins))
    except:
        bot.send_message(m.chat.id, "Ошибка")

def set_reminder(m, mins):
    bot.send_message(m.chat.id, f"Напомню через {mins} минут")
    threading.Timer(mins * 60, lambda: bot.send_message(m.chat.id, f"Напоминание:\n{m.text}")).start()

# Список дел
def add_task(m, user_id):
    df = load_tasks()
    new_task = pd.DataFrame({'user_id': [user_id], 'task': [m.text], 'done': [False]})
    df = pd.concat([df, new_task], ignore_index=True)
    save_tasks(df)
    bot.send_message(m.chat.id, "Дело добавлено")

def show_tasks(m, user_id):
    df = load_tasks()
    user_tasks = df[df['user_id'] == user_id]

    if user_tasks.empty:
        bot.send_message(m.chat.id, "Список дел пуст")
        return

    kb = types.InlineKeyboardMarkup(row_width=2)
    text = "<b>Список дела:</b>\n\n"
    for idx, row in user_tasks.iterrows():
        status = "✓" if row['done'] else "⬜"
        text += f"{status} {row['task']}\n"
        kb.add(types.InlineKeyboardButton("✓", callback_data=f"done_{idx}"),
               types.InlineKeyboardButton("✗", callback_data=f"del_{idx}"))

    bot.send_message(m.chat.id, text, parse_mode='HTML', reply_markup=kb)

@bot.callback_query_handler(func=lambda c: c.data.startswith(("done_", "del_")))
def task_action(c):
    df = load_tasks()
    idx = int(c.data.split("_")[1])

    if c.data.startswith("done_"):
        df.loc[idx, 'done'] = not df.loc[idx, 'done']
    else:
        df = df.drop(idx)

    save_tasks(df)
    bot.delete_message(c.message.chat.id, c.message.message_id)
    show_tasks(c.message, c.from_user.id)

print("Запущен")
bot.infinity_polling(none_stop=True)